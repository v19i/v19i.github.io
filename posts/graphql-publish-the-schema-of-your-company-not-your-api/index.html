<!doctype html><html lang=en-GB><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta charset=utf-8><meta http-equiv=content-style-type content="text/css"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Valerio Francescangeli"><meta name=generator content="Hugo 0.117.0"><title>GraphQL: Publish the Schema of Your Company, Not Your Api - Valerio Francescangeli</title><link rel=stylesheet type=text/css href=/css/base.min.397851f5b8b8de362dcad8e734af8ddaea32a024d5956c06c84e9e4edfa13a3d.css integrity="sha256-OXhR9bi43jYtytjnNK+N2uoyoCTVlWwGyE6eTt+hOj0="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=stylesheet type=text/css href=/css/article.min.194fd79ac8bfa99737977cad62a3405547718d04236395544bac5ce2db53f6c5.css integrity="sha256-GU/Xmsi/qZc3l3ytYqNAVUdxjQQjY5VUS6xc4ttT9sU="><link rel=canonical href=https://v19i.com/posts/graphql-publish-the-schema-of-your-company-not-your-api/></head><body><div id=content><nav><a href=/>HOME</a></nav><h1 id=graphql-publish-the-schema-of-your-company-not-your-api>GraphQL: Publish the Schema of Your Company, Not Your Api</h1><p>GraphQL is an interesting technology that promises better developer and user experience, but its usefulness can be misinterpreted as an overall better technology than what came before it.</p><p>To best utilise it, a specific organisation approach must be used. GraphQL works best when the whole organisation shares the same domain conventions. Domain Driven Design shines in a GraphQL environment, but it requires a lot of effort to change a company’s mentality and embrace it.</p><p>In this article, I’ll describe how GraphQL differs from a more common REST API approach and how to ensure a successful coexistence or migration.</p><h2 id=http-rest-api>HTTP REST API</h2><p>The default way to build a service is over the internet. All languages and libraries understand it well, and its division into different verbs provides solutions for safe, idempotent and cacheable requests.</p><p>Let’s take a library API as an example. To add a new book or to publish a new review of a book, a REST API would look like this:</p><table><thead><tr><th style=text-align:left>Method</th><th style=text-align:left>Endpoint</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><code>POST</code></td><td style=text-align:left>“/books”</td><td style=text-align:left>Create a new book</td></tr><tr><td style=text-align:left><code>POST</code></td><td style=text-align:left>“/books/:id/reviews”</td><td style=text-align:left>Create a new review</td></tr></tbody></table><p>This is fine in a typical CRUD style API, but a GraphQL one can instead leverage the business’ domain naming:</p><pre tabindex=0><code>type Mutation {
  publishBook({book info})
  publishReview({review info})
}
</code></pre><h2 id=differences-between-rest-and-graphql>Differences between REST and GraphQL</h2><h3 id=your-schema-is-your-api>Your schema is your API</h3><p>This is a significant shift from the way your endpoint will expose data. To ensure a well-structured schema, start from the business problems and produce a cohesive shared understanding of the business. Domain Driven Design is what allows an organisation to create one and use it to define what your schema should look like.</p><p>Start by defining your <strong>domain events</strong>. What events happen in your business that are definable as a step forward? Create as many as you need. Once done, organise them in a timeline and group them by context. Each context will enable consistent use of the same words across all events, even when the same word means something different in a different context.</p><p>Some events will require business rules, and those rules will require data from internal or external sources. Define those rules and where the data is coming from. This will result in an action that will generate the new domain event.</p><p>This system will help define what structure your schema will have:</p><ul><li>Internal resources are GraphQL Queries</li><li>External resources live outside of the schema and must be merged, together with the business rules, in the business layer logic</li><li>Actions are GraphQL Mutations, ready to be exposed on the schema</li></ul><p>Remember that your schema is an ever-evolving system. Embrace it, and don’t be afraid to change it when they improve your customers’ experience.</p><h4 id=common-mistake-when-migrating-from-rest>Common mistake when migrating from REST</h4><p>Don’t simply move your CRUD verbs. GraphQL’s queries and mutations can use names that make sense to the business, not an API convention.</p><p>Consider a typical REST API:</p><table><thead><tr><th style=text-align:left>Method</th><th style=text-align:left>Endpoint</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><code>GET</code></td><td style=text-align:left>“books/”</td><td style=text-align:left>Get all books</td></tr><tr><td style=text-align:left><code>GET</code></td><td style=text-align:left>“books/:id”</td><td style=text-align:left>Get a book</td></tr><tr><td style=text-align:left><code>POST</code></td><td style=text-align:left>“books/“</td><td style=text-align:left>Create a new book</td></tr><tr><td style=text-align:left><code>POST</code></td><td style=text-align:left>“books/:id/review”</td><td style=text-align:left>Create a new review</td></tr><tr><td style=text-align:left><code>PATCH</code></td><td style=text-align:left>“books/:id/review”</td><td style=text-align:left>Update a review</td></tr></tbody></table><p>A common first step is to use the same style that REST adopts:</p><pre tabindex=0><code>type Query {
  getAllBooks()
  getBook({id})
}

type Mutation {
  createBook({book data})
  createReview({bookID}, {review data})
  updateReview({bookID}, {review data})
}
</code></pre><ol><li>There is no need to stick to REST verbs if it doesn’t make sense from a business perspective. It is better to use more straightforward and more effective names.</li><li>Updates are handled differently in GraphQL. Use one big input object instead of dividing it in id and body.</li></ol><pre tabindex=0><code>type Query {
  books()
  book({id})
}

type Mutation {
  // include everything in one object, {bookID} should be included inside
  createReview({review data})
  updateReview({review data})
}
</code></pre><h3 id=versioning>Versioning</h3><p>In REST, new versions are required to clarify in what shape your data will be returned, but it is an anti-pattern in GraphQL. Multiple versions mean multiple schemas, which will get out of hand quickly.
GraphQL’s way of dealing with changes is to add new fields when necessary and tag the old ones as deprecated. There is no drawback in having a lot of fields, as every client will always require only what they need.</p><h3 id=authorisation>Authorisation</h3><p>There are no particular differences here, but if the plan is to keep both REST and GraphQL endpoint, it is better to move the authorisation logic down into the business layer to consolidate the checks in a single place and allow each endpoint to only care about passing down the correct data.</p><h3 id=query-complexity>Query Complexity</h3><p>The freedom allowed by GraphQL is a double-edged sword. Clients can optimise their queries for their use case, but what they need and ask at once might be onerous on your infrastructure. Load-testing your client’s use cases to verify how many records and how much nesting to allow must be considered when exposing your GraphQL endpoint to the public.</p><h3 id=rate-limiting>Rate limiting</h3><p>Rate limiting an API can also be challenging. Consider how each part of your schema respond to an increase of queries and implement a business logic to prevent abuse.</p><h3 id=caching>Caching</h3><p>Contrary to REST, caching in GraphQL doesn’t have a well-defined set of rules, with each client managing its cache. If one or more services rely heavily on caching to be functional, think twice before moving them to GraphQL, as it is a delicate matter even when using best practices.</p><h4 id=client-side-caching>Client Side Caching</h4><p>Client side cache, with clients like Apollo, relies on cache deduplication and normalisation to optimise the fetching and re-fetching of data. This system works similarly to an SQL database, leveraging the knowledge of the graph architecture and the information about the query to know what to load and what to skip.</p><p>Let’s assume this query:</p><pre tabindex=0><code>query GetAllBooks {
  books {
    id
    title
  }
}
</code></pre><p>That returns this data:</p><pre tabindex=0><code>{
  books: [
    {&lt;book1&gt;},
    {&lt;book2&gt;},
    {&lt;book3&gt;},
    {&lt;...&gt;},
  ]
}
</code></pre><p>By default, the normalisation process will split the data to allow it to be individually cached:</p><pre tabindex=0><code>{
  id: 1,
  __typename: &#34;Book&#34;,
  title: &#34;Book1&#34;,
}
</code></pre><p>Apollo Client will use the <code>__typename</code> and <code>id</code> to create a unique pair that will use to cache it on the client, in a quick-access data structure, like this:</p><pre tabindex=0><code>{
  &#34;Book:1&#34;: { id: 1, title: &#34;Book1&#34; },
  &#34;Book:&lt;n&gt;&#34;: { id: &lt;n&gt;, title: &lt;title&gt; },
}
</code></pre><h5 id=notes-on-client-side-caching><strong>Notes on client side caching</strong></h5><ul><li>It’s important to have a unique identifier; without it, Apollo Client won’t be able to keep track of changes to the object</li><li>The library creates an array that references the normalised data to keep the correct ordering in place.</li></ul><h4 id=server-side-caching>Server Side Caching</h4><p>Apollo Server supports server side caching. It can be applied to a type or a specific field by proving a <code>maxAge</code> value, which describes the number of seconds the cache will be considered valid.</p><p>These are the allowed properties to control the cache:</p><table><thead><tr><th style=text-align:left>Name</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><code>maxAge</code></td><td style=text-align:left>Number of seconds the resource will be cached for. Default to 0.</td></tr><tr><td style=text-align:left><code>scope</code></td><td style=text-align:left>Can be PUBLIC or PRIVATE. Use PRIVATE to make a response as specific to a single user Default is PUBLIC.</td></tr><tr><td style=text-align:left><code>inheritMaxAge</code></td><td style=text-align:left>If set to true, it will inherit the maxAge value of its parent. Make sure not to provide maxAge if you plan to use inheritMaxAge.</td></tr></tbody></table><p>It is used by using a directive called <code>@cacheControl </code>. The previous query for books could be cached for one day by having a <code>type Book</code> with this value:</p><pre tabindex=0><code>type Book @cacheControl(maxAge 86400) {
  id: String!
  title: String!
}
</code></pre><p>The caveat is that the query as a whole will be valid based on the field with the lowest maxAge value.</p><pre tabindex=0><code>type Review {
  id: String!
  book: Book!
}
</code></pre><h5 id=a-few-caching-rules><strong>A few caching rules</strong></h5><ul><li>Having <code>maxAge</code> set to 0 by default means nothing is cached out of the box. It is easier to start without cache and add it where needed, avoiding unexpected behaviours by caching too early.</li><li>If any field inside a query has a smaller <code>maxAge</code> value, the whole result will have that cache value associated with it.</li><li>If any field inside a query is set to PRIVATE, the whole response will be marked as PRIVATE.</li></ul><p><em>Here, I’ve discussed statically set cache. Note that there is a way to set the cache dynamically. This is only a small introduction to a deep topic.</em></p><h2 id=conclusion>Conclusion</h2><p>This article barely scratched what GraphQL can do for an organisation. The simplicity given by being able to organise and find data in the same way it is talked about from the business is a benefit that enables a more cohesive discussion between engineering and product, and it should not be considered an extra but instead seen as the core of it.</p><footer><time class=post-publication-date datetime=2023-06-16>16 Jun 2023</time></footer></div><script src=/js/theme-colour-updater.min.e86ef29fe900bc4a4d398f74161f815491d921b202076526f0cb0b8ce9062101.mjs type=module integrity="sha256-6G7yn+kAvEpNOY90Fh+BVJHZIbICB2Um8MsLjOkGIQE="></script></body></html>